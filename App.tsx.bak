
import React, { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import type { FileItem, ViewMode, Page, User, Role } from './types';
import { ItemType, MOCK_DATA, MOCK_USERS } from './constants';
import Sidebar from './components/Sidebar';
import Header from './components/Header';
import FileExplorer from './components/FileExplorer';
import FileDetailPanel from './components/FileDetailPanel';
import ShareModal from './components/ShareModal';
import StarredView from './components/StarredView';
import LoginScreen from './components/LoginScreen'; // Keeping for reference, but replacing usage
import AtaView from './components/AtaView';
import CloudConnectionsView from './components/CloudConnectionsView';
import PdfViewerModal from './components/PdfViewerModal';
import { LoaderCircle } from 'lucide-react';
import AllFilesView from './components/AllFilesView';
import ConnectCloudModal from './components/ConnectCloudModal';
import HomeView from './components/HomeView';
import { supabase } from './lib/supabase';
import LoginView from './components/auth/LoginView';
import SignupView from './components/auth/SignupView';

const GOOGLE_CLIENT_ID = "409424537697-vavde7jsobj6ormha3jkck9trkluv743.apps.googleusercontent.com";
const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/drive';
const DROPBOX_CLIENT_ID = '526sxx6ouop0kwl';
const DROPBOX_REDIRECT_URI = window.location.origin + '/dropbox-auth';

declare global {
  interface Window {
    gapi: any;
    google: any;
    Dropbox: any;
  }
}

type ActiveCloud = 'google' | 'dropbox' | null;

export default function App() {
  const [session, setSession] = useState<any>(null);
  const [authView, setAuthView] = useState<'login' | 'signup'>('login');
  const [isLoadingSession, setIsLoadingSession] = useState(true);

  const [allItems, setAllItems] = useState<FileItem[]>([]);
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [currentFolderId, setCurrentFolderId] = useState<string | null>(null);
  const [viewMode, setViewMode] = useState<ViewMode>('grid');
  const [selectedItem, setSelectedItem] = useState<FileItem | null>(null);
  const [sharingItem, setSharingItem] = useState<FileItem | null>(null);
  const [activePage, setActivePage] = useState<Page>('home');
  const [fullScreenPreviewItem, setFullScreenPreviewItem] = useState<FileItem | null>(null);
  const [isSidebarOpen, setSidebarOpen] = useState(false);

  const [activeCloud, setActiveCloud] = useState<ActiveCloud>(null);
  const [isDriveConnected, setDriveConnected] = useState(false);
  const [isDropboxConnected, setDropboxConnected] = useState(false);

  const [isLoadingFiles, setIsLoadingFiles] = useState(false);
  const [googleTokenClient, setGoogleTokenClient] = useState<any>(null);
  const [dropboxClient, setDropboxClient] = useState<any>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const gapiInited = useRef(false);
  const gisInited = useRef(false);
  const [isConnecting, setIsConnecting] = useState(false);

  const [isConnectModalOpen, setConnectModalOpen] = useState(false);

  const activeCloudRef = useRef<ActiveCloud>(null);
  const dropboxClientRef = useRef<any>(null);
  useEffect(() => { activeCloudRef.current = activeCloud; }, [activeCloud]);
  useEffect(() => { dropboxClientRef.current = dropboxClient; }, [dropboxClient]);

  const [recentFiles, setRecentFiles] = useState<FileItem[]>([]);

  // --- Supabase Auth Logic ---
  useEffect(() => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      if (session?.user) {
        // Fetch user profile
        fetchUserProfile(session.user.id);
      }
      setIsLoadingSession(false);
    });

    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
      if (session?.user) {
        fetchUserProfile(session.user.id);
      } else {
        setCurrentUser(null);
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  const fetchUserProfile = async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();

      if (data) {
        setCurrentUser({
          id: data.id,
          name: data.name || 'Usuário',
          email: session?.user?.email || '',
          avatar: data.avatar_url,
          role: 'admin', // Default role for now
        });
      } else {
        // Fallback if profile doesn't exist yet (e.g. just signed up)
        setCurrentUser({
          id: userId,
          name: session?.user?.user_metadata?.name || 'Usuário',
          email: session?.user?.email || '',
          role: 'admin',
        });
      }
    } catch (error) {
      console.error('Error fetching profile:', error);
    }
  };

  // --- Google Drive specific logic ---
  const initGapi = useCallback(() => {
    return new Promise<void>((resolve, reject) => {
      if (gapiInited.current) return resolve();
      if (typeof window.gapi?.load !== 'function') return reject(new Error('GAPI script not loaded.'));
      window.gapi.load('client', () => {
        window.gapi.client.init({
          discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
        }).then(() => { gapiInited.current = true; resolve(); }).catch(reject);
      });
    });
  }, []);

  const initGis = useCallback(() => {
    return new Promise<any>((resolve, reject) => {
      if (gisInited.current && googleTokenClient) return resolve(googleTokenClient);
      if (typeof window.google?.accounts?.oauth2?.initTokenClient !== 'function') return reject(new Error('GIS script not loaded.'));
      const client = window.google.accounts.oauth2.initTokenClient({
        client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_SCOPES,
        callback: (tokenResponse: any) => {
          if (tokenResponse && tokenResponse.access_token) {
            window.gapi.client.setToken(tokenResponse);
            setDriveConnected(true);
            setActiveCloud('google');
            localStorage.setItem('google_auth_token', JSON.stringify(tokenResponse));
          }
        },
      });
      setGoogleTokenClient(client);
      gisInited.current = true;
      resolve(client);
    });
  }, [googleTokenClient]);

  const handleDisconnectGoogleDrive = useCallback(() => {
    const token = JSON.parse(localStorage.getItem('google_auth_token') || '{}');
    if (token.access_token && window.google?.accounts?.oauth2) {
      window.google.accounts.oauth2.revoke(token.access_token, () => { });
    }
    localStorage.removeItem('google_auth_token');
    localStorage.removeItem('linkarbox_keep_connected_google');
    setDriveConnected(false);
    if (activeCloudRef.current === 'google') setActiveCloud(null);
  }, []);

  // --- Dropbox specific logic ---
  const handleConnectDropbox = useCallback(() => {
    const dbxAuth = new window.Dropbox.DropboxAuth({ clientId: DROPBOX_CLIENT_ID });
    dbxAuth.getAuthenticationUrl(DROPBOX_REDIRECT_URI, undefined, 'token')
      .then((authUrl: string) => {
        window.location.href = authUrl;
      })
      .catch((error: any) => {
        console.error('Dropbox Authentication Error:', error);
        alert('Could not initiate Dropbox authentication. Please check the console.');
      });
  }, []);

  const handleDisconnectDropbox = useCallback(async () => {
    try {
      if (dropboxClientRef.current && dropboxClientRef.current.auth) {
        await dropboxClientRef.current.auth.tokenRevoke();
      }
    } catch (error) {
      console.error("Error revoking Dropbox token:", error);
    } finally {
      localStorage.removeItem('dropbox_auth_token');
      localStorage.removeItem('linkarbox_keep_connected_dropbox');
      setDropboxConnected(false);
      setDropboxClient(null);
      if (activeCloudRef.current === 'dropbox') setActiveCloud(null);
    }
  }, []);

  // --- Unified Cloud Logic ---
  useEffect(() => {
    const handleDropboxRedirect = async () => {
      if (window.location.pathname !== '/dropbox-auth') return;
      const hash = window.location.hash || '';
      if (!hash.includes('access_token')) {
        window.history.replaceState({}, document.title, '/');
        return;
      }
      const params = new URLSearchParams(hash.substring(1));
      const accessToken = params.get('access_token');
      if (accessToken) {
        localStorage.setItem('dropbox_auth_token', accessToken);
        const dbx = new window.Dropbox.Dropbox({ accessToken });
        try {
          await dbx.usersGetCurrentAccount();
          setDropboxClient(dbx);
          setDropboxConnected(true);
          setActiveCloud('dropbox');
        } catch (error) {
          console.error('Dropbox token validation failed:', error);
          alert('Failed to validate Dropbox token. Please try connecting again.');
          localStorage.removeItem('dropbox_auth_token');
        } finally {
          window.history.replaceState({}, document.title, '/');
        }
      } else {
        window.history.replaceState({}, document.title, '/');
      }
    };
    handleDropboxRedirect();
  }, []);


  useEffect(() => {
    if (!currentUser) return;

    const tryAutoConnect = async () => {
      setIsConnecting(true);
      let hasConnected = false;

      const keepGoogle = localStorage.getItem('linkarbox_keep_connected_google') === 'true';
      const googleTokenStr = localStorage.getItem('google_auth_token');
      if (keepGoogle && googleTokenStr) {
        try {
          await initGapi();
          window.gapi.client.setToken(JSON.parse(googleTokenStr));
          await window.gapi.client.drive.about.get({ fields: 'user' });
          setDriveConnected(true);
          setActiveCloud('google');
          hasConnected = true;
          setIsConnecting(false);
          return;
        } catch (error) {
          console.error("Google auto-connect failed", error);
          handleDisconnectGoogleDrive();
        }
      }

      const keepDropbox = localStorage.getItem('linkarbox_keep_connected_dropbox') === 'true';
      const dropboxToken = localStorage.getItem('dropbox_auth_token');
      if (keepDropbox && dropboxToken) {
        try {
          const dbx = new window.Dropbox.Dropbox({ accessToken: dropboxToken });
          await dbx.usersGetCurrentAccount();
          setDropboxClient(dbx);
          setDropboxConnected(true);
          setActiveCloud('dropbox');
          hasConnected = true;
          setIsConnecting(false);
          return;
        } catch (error) {
          console.error("Dropbox auto-connect failed", error);
          handleDisconnectDropbox();
        }
      }

      setIsConnecting(false);
      // Modal disabled - users can connect via Home page
      // if (!hasConnected && currentUser.role === 'architect') {
      //   setConnectModalOpen(true);
      // }
    };
    tryAutoConnect();
  }, [currentUser, initGapi, handleDisconnectGoogleDrive, handleDisconnectDropbox]);

  const fetchFiles = useCallback(async (folderId: string) => {
    setIsLoadingFiles(true);
    try {
      let formatted: FileItem[] = [];
      const cloud = activeCloudRef.current;
      const dbx = dropboxClientRef.current;

      if (cloud === 'google') {
        const resp = await window.gapi.client.drive.files.list({
          q: `'${folderId}' in parents and trashed = false`,
          fields: 'files(id, name, mimeType, modifiedTime, starred, parents, size)',
          pageSize: 100,
        });
        const files = resp.result.files || [];
        formatted = files.map((f: any) => ({
          id: f.id,
          name: f.name,
          type: f.mimeType === 'application/vnd.google-apps.folder' ? ItemType.FOLDER : ItemType.FILE,
          parentId: f.parents ? f.parents[0] : null,
          mimeType: f.mimeType,
          isStarred: f.starred,
          sharedWith: [],
          modified: new Date(f.modifiedTime).toLocaleDateString(),
          size: f.size,
        }));
      } else if (cloud === 'dropbox' && dbx) {
        let result = await dbx.filesListFolder({ path: folderId === 'root' ? '' : folderId });
        const entries: any[] = [...result.result.entries];
        while (result.result.has_more) {
          result = await dbx.filesListFolderContinue({ cursor: result.result.cursor });
          entries.push(...result.result.entries);
        }
        formatted = entries.map((e: any) => {
          let mimeType = e.mime_type;
          const lowerName = e.name.toLowerCase();
          if (!mimeType) {
            if (lowerName.endsWith('.pdf')) mimeType = 'application/pdf';
            else if (lowerName.endsWith('.png')) mimeType = 'image/png';
            else if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg')) mimeType = 'image/jpeg';
          }
          return {
            id: e.path_lower,
            name: e.name,
            type: e['.tag'] === 'folder' ? ItemType.FOLDER : ItemType.FILE,
            parentId: folderId,
            mimeType: mimeType,
            cloudId: e.id, // Store the actual Dropbox ID
            isStarred: false,
            sharedWith: [],
            modified: e.client_modified ? new Date(e.client_modified).toLocaleDateString() : 'N/A',
            size: e.size,
          };
        });
      }
      setAllItems(formatted);
    } catch (err: any) {
      console.error('Error fetching files:', err);
      if (err?.status === 429) {
        const retryAfter =
          Number(err?.error?.headers?.get?.('Retry-After')) ||
          Number(err?.response?.headers?.get?.('Retry-After')) ||
          2;
        setTimeout(() => fetchFiles(folderId), retryAfter * 1000);
        return;
      }
      if (activeCloudRef.current === 'google' && (err.status === 401 || err.result?.error?.status === 'UNAUTHENTICATED')) {
        handleDisconnectGoogleDrive();
      } else if (activeCloudRef.current === 'dropbox' && err.status === 401) {
        handleDisconnectDropbox();
      }
    } finally {
      setIsLoadingFiles(false);
    }
  }, [handleDisconnectDropbox, handleDisconnectGoogleDrive]);

  // Handlers for UI interactions
  const handleSetPage = useCallback((page: Page) => {
    setActivePage(page);
    setSidebarOpen(false); // Close sidebar on navigation
    setSelectedItem(null); // Clear selected item when changing page
    setCurrentFolderId(null); // Reset folder view
  }, []);

  const handleSearch = useCallback((query: string) => {
    console.log('Searching for:', query);
    // Implement search logic here
  }, []);

  const handleModalConnect = useCallback((cloud: 'google' | 'dropbox') => {
    setIsConnecting(true);
    if (cloud === 'google') {
      initGapi().then(() => initGis().then(client => client.requestAccessToken()));
    } else if (cloud === 'dropbox') {
      handleConnectDropbox();
    }
    setConnectModalOpen(false);
  }, [initGapi, initGis, handleConnectDropbox]);

  const handleModalSkip = useCallback(() => {
    setConnectModalOpen(false);
  }, []);

  const handleFileChange = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    const file = files[0];
    console.log('Uploading file:', file.name);

    // Reset the input value to allow uploading the same file again
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }

    // Implement upload logic here
    // For now, just simulate an upload
    setIsLoadingFiles(true);
    setTimeout(() => {
      const newFile: FileItem = {
        id: `local-${Date.now()}`,
        name: file.name,
        type: ItemType.FILE,
        parentId: currentFolderId || 'root',
        mimeType: file.type || 'application/octet-stream',
        isStarred: false,
        sharedWith: [],
        modified: new Date().toLocaleDateString(),
        size: file.size,
      };
      setAllItems(prev => [...prev, newFile]);
      setIsLoadingFiles(false);
      alert(`File "${file.name}" uploaded successfully (simulated).`);
    }, 1500);
  }, [currentFolderId]);

  const handleUploadClick = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleCreateFolder = useCallback((folderName: string) => {
    console.log('Creating folder:', folderName);
    // Implement folder creation logic here
    const newFolder: FileItem = {
      id: `folder-${Date.now()}`,
      name: folderName,
      type: ItemType.FOLDER,
      parentId: currentFolderId || 'root',
      mimeType: 'application/vnd.google-apps.folder',
      isStarred: false,
      sharedWith: [],
      modified: new Date().toLocaleDateString(),
      size: 0,
    };
    setAllItems(prev => [...prev, newFolder]);
  }, [currentFolderId]);

  const handleRenameItem = useCallback((itemId: string, newName: string) => {
    console.log(`Renaming item ${itemId} to ${newName}`);
    setAllItems(prev => prev.map(item => item.id === itemId ? { ...item, name: newName } : item));
  }, []);

  const handleDeleteItem = useCallback((itemId: string) => {
    console.log(`Deleting item ${itemId}`);
    setAllItems(prev => prev.filter(item => item.id !== itemId));
    setSelectedItem(null); // Deselect if deleted
  }, []);

  const handleShareItem = useCallback((item: FileItem) => {
    setSharingItem(item);
  }, []);

  const handleToggleStar = useCallback((itemId: string) => {
    setAllItems(prev => prev.map(item => item.id === itemId ? { ...item, isStarred: !item.isStarred } : item));
  }, []);

  const handleDownloadItem = useCallback(async (item: FileItem) => {
    console.log('Downloading item:', item.name);
    if (activeCloud === 'google') {
      try {
        await initGapi();
        const response = await window.gapi.client.drive.files.get({
          fileId: item.id,
          alt: 'media',
        });
        const blob = new Blob([response.body], { type: item.mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = item.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Error downloading Google Drive file:', error);
        alert('Failed to download file from Google Drive.');
      }
    } else if (activeCloud === 'dropbox' && dropboxClient) {
      try {
        const response = await dropboxClient.filesDownload({ path: item.id });
        const blob = response.result.fileBlob;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = item.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Error downloading Dropbox file:', error);
        alert('Failed to download file from Dropbox.');
      }
    } else {
      alert('Download not supported for this cloud or item type.');
    }
  }, [activeCloud, dropboxClient, initGapi]);

  const handleOpenItem = useCallback((item: FileItem) => {
    if (item.type === ItemType.FOLDER) {
      setCurrentFolderId(item.id);
      setSelectedItem(null); // Clear selection when entering folder
    } else {
      setSelectedItem(item);
      // For files, if it's a PDF, open in full screen preview
      if (item.mimeType === 'application/pdf') {
        setFullScreenPreviewItem(item);
      }
    }
  }, []);

  const handleGoBack = useCallback(() => {
    if (currentFolderId) {
      // This is a simplified back. In a real app, you'd track folder history.
      // For now, just go back to 'root' or the parent of the current folder.
      // This requires knowing the parent ID, which isn't directly available for all items.
      // For simplicity, we'll just go to 'root' for now.
      setCurrentFolderId('root');
      setSelectedItem(null);
    }
  }, [currentFolderId]);

  // Filter items based on current folder and active page
  const filteredItems = useMemo(() => {
    let items = allItems;

    if (activePage === 'starred') {
      items = items.filter(item => item.isStarred);
    } else if (activePage === 'all-files') {
      // No additional filtering for 'all-files' beyond folder structure
    } else if (activePage === 'home') {
      // For home, show recent files or a mix
      items = recentFiles.length > 0 ? recentFiles : allItems.slice(0, 5); // Example: show some recent or first 5
    }

    // Filter by current folder if not 'all-files' or 'starred'
    if (activePage !== 'starred' && activePage !== 'home' && activePage !== 'cloud' && activePage !== 'atas') {
      const parentId = currentFolderId || 'root';
      items = items.filter(item => item.parentId === parentId);
    }

    return items;
  }, [allItems, activePage, currentFolderId, recentFiles]);

  // Fetch files when activeCloud or currentFolderId changes
  useEffect(() => {
    if (activeCloud && currentUser) {
      const folderToFetch = currentFolderId || 'root';
      fetchFiles(folderToFetch);
    } else {
      setAllItems([]); // Clear files if no cloud is active
    }
  }, [activeCloud, currentFolderId, fetchFiles, currentUser]);

  // Mock recent files for Home view
  useEffect(() => {
    if (allItems.length > 0) {
      // Take a few random files as "recent"
      const shuffled = [...allItems].sort(() => 0.5 - Math.random());
      setRecentFiles(shuffled.slice(0, Math.min(shuffled.length, 5)));
    }
  }, [allItems]);

  // Render content based on active page
  const renderContent = useCallback(() => {
    switch (activePage) {
      case 'home':
        return (
          <HomeView
            recentFiles={recentFiles}
            onOpenFile={handleOpenItem}
            onConnectCloud={() => setConnectModalOpen(true)}
            isDriveConnected={isDriveConnected}
            isDropboxConnected={isDropboxConnected}
            onDisconnectGoogleDrive={handleDisconnectGoogleDrive}
            onDisconnectDropbox={handleDisconnectDropbox}
            onConnectGoogleDrive={() => initGapi().then(() => initGis().then(client => client.requestAccessToken()))}
            onConnectDropbox={handleConnectDropbox}
            isLoadingFiles={isLoadingFiles}
          />
        );
      case 'all-files':
        return (
          <FileExplorer
            items={filteredItems}
            viewMode={viewMode}
            onItemClick={handleOpenItem}
            onItemSelect={setSelectedItem}
            selectedItem={selectedItem}
            onViewModeChange={setViewMode}
            onUploadClick={handleUploadClick}
            onCreateFolder={handleCreateFolder}
            onRenameItem={handleRenameItem}
            onDeleteItem={handleDeleteItem}
            onShareItem={handleShareItem}
            onToggleStar={handleToggleStar}
            onDownloadItem={handleDownloadItem}
            isLoading={isLoadingFiles}
            currentFolderId={currentFolderId}
            onGoBack={handleGoBack}
            activeCloud={activeCloud}
          />
        );
      case 'starred':
        return (
          <StarredView
            starredItems={filteredItems}
            onItemClick={handleOpenItem}
            onItemSelect={setSelectedItem}
            selectedItem={selectedItem}
            onToggleStar={handleToggleStar}
            onDownloadItem={handleDownloadItem}
            isLoading={isLoadingFiles}
          />
        );
      case 'atas':
        return <AtaView />;
      case 'cloud':
        return (
          <CloudConnectionsView
            isDriveConnected={isDriveConnected}
            isDropboxConnected={isDropboxConnected}
            onConnectGoogleDrive={() => initGapi().then(() => initGis().then(client => client.requestAccessToken()))}
            onDisconnectGoogleDrive={handleDisconnectGoogleDrive}
            onConnectDropbox={handleConnectDropbox}
            onDisconnectDropbox={handleDisconnectDropbox}
            activeCloud={activeCloud}
            onSetActiveCloud={setActiveCloud}
          />
        );
      default:
        return <div className="p-4 text-gray-600">Select a page from the sidebar.</div>;
    }
  }, [
    activePage, filteredItems, viewMode, selectedItem, handleOpenItem, setSelectedItem,
    setViewMode, handleUploadClick, handleCreateFolder, handleRenameItem, handleDeleteItem,
    handleShareItem, handleToggleStar, handleDownloadItem, isLoadingFiles, currentFolderId,
    handleGoBack, recentFiles, isDriveConnected, isDropboxConnected, handleDisconnectGoogleDrive,
    handleDisconnectDropbox, initGapi, initGis, handleConnectDropbox, activeCloud,
  ]);

  // Replace conditional rendering at the end
  if (isLoadingSession) {
    return <div className="flex items-center justify-center h-screen bg-[#F7F9FC]"><LoaderCircle className="w-12 h-12 text-primary animate-spin" /></div>;
  }

  if (!session) {
    return authView === 'login' ? (
      <LoginView onNavigateToSignup={() => setAuthView('signup')} />
    ) : (
      <SignupView onNavigateToLogin={() => setAuthView('login')} />
    );
  }

  if (!currentUser) return <div className="flex items-center justify-center h-screen bg-[#F7F9FC]"><LoaderCircle className="w-12 h-12 text-primary animate-spin" /></div>;

  return (
    <div className="flex h-screen bg-[#F7F9FC] font-sans overflow-hidden">
      <ConnectCloudModal isOpen={isConnectModalOpen} onConnect={handleModalConnect} onSkip={handleModalSkip} isConnecting={isConnecting} />

      {/* Sidebar */}
      <Sidebar
        activePage={activePage}
        onNavigate={handleSetPage}
        storageUsed={114} // Mocked for now
        storageTotal={15} // Mocked for now
        isOpen={isSidebarOpen}
        onClose={() => setSidebarOpen(false)}
        onLogout={async () => {
          await supabase.auth.signOut();
          setDriveConnected(false);
          setDropboxConnected(false);
          setActiveCloud(null);
        }}
      />

      {/* Main Content */}
      <div className="flex-1 flex flex-col min-w-0 overflow-hidden relative">
        {/* Header */}
        <Header
          user={currentUser}
          onSearch={handleSearch}
          onToggleSidebar={() => setSidebarOpen(!isSidebarOpen)}
          title={activePage === 'home' ? 'Meu Linkarbox' : activePage === 'starred' ? 'Favoritos' : activePage === 'atas' ? 'Atas de Reunião' : activePage === 'cloud' ? 'Conexões' : currentFolderId === 'root' ? 'Todos os Arquivos' : 'Navegando...'}
        />

        {/* Content Area */}
        <main className="flex-1 overflow-y-auto p-4 md:p-6 relative">
          {renderContent()}
        </main>

        {/* File Detail Panel */}
        {selectedItem && (
          <FileDetailPanel
            item={selectedItem}
            onClose={() => setSelectedItem(null)}
            onRename={handleRenameItem}
            onDelete={handleDeleteItem}
            onShare={handleShareItem}
            onToggleStar={handleToggleStar}
            onDownload={handleDownloadItem}
          />
        )}

        {/* Full Screen Preview */}
        {fullScreenPreviewItem && (
          <PdfViewerModal
            file={fullScreenPreviewItem}
            isOpen={!!fullScreenPreviewItem}
            onClose={() => setFullScreenPreviewItem(null)}
            cloudProvider={activeCloud || 'dropbox'} // Default to dropbox if null, but logic should prevent this
            accessToken={activeCloud === 'google' ? gapi.client.getToken()?.access_token : undefined} // Pass token for Google
          />
        )}
      </div>

      {/* Modals */}
      <ShareModal
        isOpen={!!sharingItem}
        onClose={() => setSharingItem(null)}
        item={sharingItem}
      />

      {/* Hidden File Input for Upload */}
      <input
        type="file"
        ref={fileInputRef}
        className="hidden"
        onChange={handleFileChange}
      />
    </div>
  );
}
}, []);

// --- Dropbox specific logic ---
const handleConnectDropbox = useCallback(() => {
  const dbxAuth = new window.Dropbox.DropboxAuth({ clientId: DROPBOX_CLIENT_ID });
  dbxAuth.getAuthenticationUrl(DROPBOX_REDIRECT_URI, undefined, 'token')
    .then((authUrl: string) => {
      window.location.href = authUrl;
    })
    .catch((error: any) => {
      console.error('Dropbox Authentication Error:', error);
      alert('Could not initiate Dropbox authentication. Please check the console.');
    });
}, []);

const handleDisconnectDropbox = useCallback(async () => {
  try {
    if (dropboxClientRef.current && dropboxClientRef.current.auth) {
      await dropboxClientRef.current.auth.tokenRevoke();
    }
  } catch (error) {
    console.error("Error revoking Dropbox token:", error);
  } finally {
    localStorage.removeItem('dropbox_auth_token');
    localStorage.removeItem('linkarbox_keep_connected_dropbox');
    setDropboxConnected(false);
    setDropboxClient(null);
    if (activeCloudRef.current === 'dropbox') setActiveCloud(null);
  }
}, []);

// --- Unified Cloud Logic ---
useEffect(() => {
  const handleDropboxRedirect = async () => {
    if (window.location.pathname !== '/dropbox-auth') return;
    const hash = window.location.hash || '';
    if (!hash.includes('access_token')) {
      window.history.replaceState({}, document.title, '/');
      return;
    }
    const params = new URLSearchParams(hash.substring(1));
    const accessToken = params.get('access_token');
    if (accessToken) {
      localStorage.setItem('dropbox_auth_token', accessToken);
      const dbx = new window.Dropbox.Dropbox({ accessToken });
      try {
        await dbx.usersGetCurrentAccount();
        setDropboxClient(dbx);
        setDropboxConnected(true);
        setActiveCloud('dropbox');
      } catch (error) {
        console.error('Dropbox token validation failed:', error);
        alert('Failed to validate Dropbox token. Please try connecting again.');
        localStorage.removeItem('dropbox_auth_token');
      } finally {
        window.history.replaceState({}, document.title, '/');
      }
    } else {
      window.history.replaceState({}, document.title, '/');
    }
  };
  handleDropboxRedirect();
}, []);


useEffect(() => {
  if (!currentUser) return;

  const tryAutoConnect = async () => {
    setIsConnecting(true);
    let hasConnected = false;

    const keepGoogle = localStorage.getItem('linkarbox_keep_connected_google') === 'true';
    const googleTokenStr = localStorage.getItem('google_auth_token');
    if (keepGoogle && googleTokenStr) {
      try {
        await initGapi();
        window.gapi.client.setToken(JSON.parse(googleTokenStr));
        await window.gapi.client.drive.about.get({ fields: 'user' });
        setDriveConnected(true);
        setActiveCloud('google');
        hasConnected = true;
        setIsConnecting(false);
        return;
      } catch (error) {
        console.error("Google auto-connect failed", error);
        handleDisconnectGoogleDrive();
      }
    }

    const keepDropbox = localStorage.getItem('linkarbox_keep_connected_dropbox') === 'true';
    const dropboxToken = localStorage.getItem('dropbox_auth_token');
    if (keepDropbox && dropboxToken) {
      try {
        const dbx = new window.Dropbox.Dropbox({ accessToken: dropboxToken });
        await dbx.usersGetCurrentAccount();
        setDropboxClient(dbx);
        setDropboxConnected(true);
        setActiveCloud('dropbox');
        hasConnected = true;
        setIsConnecting(false);
        return;
      } catch (error) {
        console.error("Dropbox auto-connect failed", error);
        handleDisconnectDropbox();
      }
    }

    setIsConnecting(false);
    // Modal disabled - users can connect via Home page
    // if (!hasConnected && currentUser.role === 'architect') {
    //   setConnectModalOpen(true);
    // }
  };
  tryAutoConnect();
}, [currentUser, initGapi, handleDisconnectGoogleDrive, handleDisconnectDropbox]);

const fetchFiles = useCallback(async (folderId: string) => {
  setIsLoadingFiles(true);
  try {
    let formatted: FileItem[] = [];
    const cloud = activeCloudRef.current;
    const dbx = dropboxClientRef.current;

    if (cloud === 'google') {
      const resp = await window.gapi.client.drive.files.list({
        q: `'${folderId}' in parents and trashed = false`,
        fields: 'files(id, name, mimeType, modifiedTime, starred, parents, size)',
        pageSize: 100,
      });
      const files = resp.result.files || [];
      formatted = files.map((f: any) => ({
        id: f.id,
        name: f.name,
        type: f.mimeType === 'application/vnd.google-apps.folder' ? ItemType.FOLDER : ItemType.FILE,
        parentId: f.parents ? f.parents[0] : null,
        mimeType: f.mimeType,
        isStarred: f.starred,
        sharedWith: [],
        modified: new Date(f.modifiedTime).toLocaleDateString(),
        size: f.size,
      }));
    } else if (cloud === 'dropbox' && dbx) {
      let result = await dbx.filesListFolder({ path: folderId === 'root' ? '' : folderId });
      const entries: any[] = [...result.result.entries];
      while (result.result.has_more) {
        result = await dbx.filesListFolderContinue({ cursor: result.result.cursor });
        entries.push(...result.result.entries);
      }
      formatted = entries.map((e: any) => {
        let mimeType = e.mime_type;
        const lowerName = e.name.toLowerCase();
        if (!mimeType) {
          if (lowerName.endsWith('.pdf')) mimeType = 'application/pdf';
          else if (lowerName.endsWith('.png')) mimeType = 'image/png';
          else if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg')) mimeType = 'image/jpeg';
        }
        return {
          id: e.path_lower,
          name: e.name,
          type: e['.tag'] === 'folder' ? ItemType.FOLDER : ItemType.FILE,
          parentId: folderId,
          mimeType: mimeType,
          cloudId: e.id, // Store the actual Dropbox ID
          isStarred: false,
          sharedWith: [],
          modified: e.client_modified ? new Date(e.client_modified).toLocaleDateString() : 'N/A',
          size: e.size,
        };
      });
    }
    setAllItems(formatted);
  } catch (err: any) {
    console.error('Error fetching files:', err);
    if (err?.status === 429) {
      const retryAfter =
        Number(err?.error?.headers?.get?.('Retry-After')) ||
        Number(err?.response?.headers?.get?.('Retry-After')) ||
        2;
      setTimeout(() => fetchFiles(folderId), retryAfter * 1000);
      return;
    }
    if (activeCloudRef.current === 'google' && (err.status === 401 || err.result?.error?.status === 'UNAUTHENTICATED')) {
      handleDisconnectGoogleDrive();
    } else if (activeCloudRef.current === 'dropbox' && err.status === 401) {
      handleDisconnectDropbox();
    }
  } finally {
    setIsLoadingFiles(false);
  }
}, [handleDisconnectDropbox, handleDisconnectGoogleDrive]);

const fetchRecentFiles = useCallback(async () => {
  try {
    let formatted: FileItem[] = [];
    const cloud = activeCloudRef.current;
    const dbx = dropboxClientRef.current;

    if (cloud === 'google') {
      // Google Drive: Get files ordered by modifiedTime desc
      const resp = await window.gapi.client.drive.files.list({
        q: 'trashed = false',
        orderBy: 'modifiedTime desc',
        fields: 'files(id, name, mimeType, modifiedTime, starred, parents, size)',
        pageSize: 20, // Get top 20 most recent files
      });
      const files = resp.result.files || [];
      formatted = files.map((f: any) => ({
        id: f.id,
        name: f.name,
        type: f.mimeType === 'application/vnd.google-apps.folder' ? ItemType.FOLDER : ItemType.FILE,
        parentId: f.parents ? f.parents[0] : null,
        mimeType: f.mimeType,
        isStarred: f.starred,
        sharedWith: [],
        modified: new Date(f.modifiedTime).toLocaleDateString(),
        size: f.size,
      }));
    } else if (cloud === 'dropbox' && dbx) {
      // Dropbox: Use search_v2 with order_by last_modified_time
      const searchResult = await dbx.filesSearchV2({
        query: '',
        options: {
          max_results: 20,
          order_by: { '.tag': 'last_modified_time' },
          file_status: { '.tag': 'active' },
        },
      });

      formatted = searchResult.result.matches.map((match: any) => {
        const e = match.metadata.metadata;
        const mimeType = e.name.endsWith('.pdf') ? 'application/pdf' :
          e.name.endsWith('.jpg') || e.name.endsWith('.png') ? 'image/*' :
            e.name.endsWith('.doc') || e.name.endsWith('.docx') ? 'application/msword' : 'application/octet-stream';

        return {
          id: e.path_display || e.id,
          name: e.name,
          type: e['.tag'] === 'folder' ? ItemType.FOLDER : ItemType.FILE,
          parentId: '',
          mimeType: mimeType,
          cloudId: e.id,
          isStarred: false,
          sharedWith: [],
          modified: e.client_modified ? new Date(e.client_modified).toLocaleDateString() : 'N/A',
          size: e.size,
        };
      });
    }

    setRecentFiles(formatted);
  } catch (err: any) {
    console.error('Error fetching recent files:', err);
    setRecentFiles([]);
  }
}, [activeCloud]);

useEffect(() => {
  if (currentFolderId) {
    fetchFiles(currentFolderId);
  }
}, [currentFolderId, fetchFiles]);

// Fetch recent files when cloud is connected
useEffect(() => {
  if (activeCloud) {
    fetchRecentFiles();
  } else {
    setRecentFiles([]);
  }
}, [activeCloud, fetchRecentFiles]);

useEffect(() => {
  if (activeCloud && currentFolderId == null) {
    setCurrentFolderId('root');
    setActivePage('all-files');
  }
  if (!activeCloud) {
    setCurrentFolderId(null);
    setAllItems([]); // Changed from MOCK_DATA to []
    // Only navigate to 'home' if not on the 'cloud' settings page
    if (activePage !== 'cloud') {
      setActivePage('home');
    }
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [activeCloud]);

const lastFetchKeyRef = useRef<string | null>(null);

useEffect(() => {
  if (!activeCloud || !currentFolderId || activePage === 'starred' || activePage === 'atas') return;

  const key = `${activeCloud}:${currentFolderId}`;
  if (lastFetchKeyRef.current === key) return;
  lastFetchKeyRef.current = key;

  fetchFiles(currentFolderId);
}, [activeCloud, currentFolderId, activePage, fetchFiles]);

const handleConnectGoogleDrive = async () => {
  setIsConnecting(true);
  if (isDropboxConnected) handleDisconnectDropbox();
  try {
    await initGapi();
    const client = await initGis();
    client.requestAccessToken({ prompt: 'consent' });
  } catch (error) {
    console.error("Failed to connect to Google Drive", error);
  } finally {
    setIsConnecting(false);
  }
};

const handleLogin = (role: Role) => setCurrentUser(Object.values(MOCK_USERS).find(u => u.role === role) || null);

const handleLogout = () => {
  setCurrentUser(null);
  handleDisconnectGoogleDrive();
  handleDisconnectDropbox();
  setActivePage('home');
  setCurrentFolderId(null);
  setSelectedItem(null);
};

const handleSetPage = useCallback((page: Page) => {
  setActivePage(page);
  setSelectedItem(null);
  if (page === 'home') {
    setCurrentFolderId('root');
  }
}, []);

const handleModalConnect = (cloud: 'google' | 'dropbox', keepConnected: boolean) => {
  if (cloud === 'google') {
    if (keepConnected) localStorage.setItem('linkarbox_keep_connected_google', 'true');
    else localStorage.removeItem('linkarbox_keep_connected_google');
    handleConnectGoogleDrive();
  } else {
    if (keepConnected) localStorage.setItem('linkarbox_keep_connected_dropbox', 'true');
    else localStorage.removeItem('linkarbox_keep_connected_dropbox');
    handleConnectDropbox();
  }
  setConnectModalOpen(false);
};

const handleModalSkip = () => setConnectModalOpen(false);

const path = useMemo(() => {
  if (activeCloud === 'google') {
    return []; // Path logic for GDrive needs implementation
  }
  if (activeCloud === 'dropbox') {
    if (!currentFolderId || currentFolderId === 'root') return [];
    const parts = currentFolderId.split('/').filter(p => p);
    const breadcrumbs = parts.map((part, i) => {
      const fullPath = '/' + parts.slice(0, i + 1).join('/');
      return {
        id: fullPath,
        name: part,
        type: ItemType.FOLDER,
        parentId: i === 0 ? 'root' : '/' + parts.slice(0, i).join('/'),
      } as FileItem
    });
    // The "root" or "home" button is handled separately in Breadcrumbs component
    return breadcrumbs;
  }
  return [];
}, [currentFolderId, activeCloud]);

const displayedItems = useMemo(() => {
  let items: FileItem[];
  if (activeCloud) {
    items = [...allItems];
  } else {
    items = allItems.filter(item => item.parentId === currentFolderId);
  }
  return items.sort((a, b) => {
    if (a.type === b.type) {
      return a.name.localeCompare(b.name);
    }
    return a.type === ItemType.FOLDER ? -1 : 1;
  });
}, [allItems, currentFolderId, activeCloud]);

const starredItems = useMemo(() => allItems.filter(item => item.isStarred), [allItems]);
const ataItems = useMemo(() => allItems.filter(item => item.isAta), [allItems]);

const handleItemClick = useCallback((item: FileItem) => {
  if (item.type === ItemType.FOLDER) {
    setCurrentFolderId(item.id);
    setSelectedItem(null);
    if (activePage !== 'all-files' && activeCloud) {
      setActivePage('all-files');
    }
  } else {
    setSelectedItem(item);
  }
}, [activePage, activeCloud]);

const handleNavigate = useCallback((folderId: string | null) => {
  setCurrentFolderId(folderId || 'root');
  setSelectedItem(null);
}, []);

const handleToggleStar = useCallback(async (itemId: string) => {
  if (activeCloud === 'google') {
    const file = allItems.find(it => it.id === itemId);
    if (!file) return;
    await window.gapi.client.drive.files.update({ fileId: itemId, resource: { starred: !file.isStarred } });
    setAllItems(prev => prev.map(it => it.id === itemId ? { ...it, isStarred: !it.isStarred } : it));
  } else {
    alert("Starring is not supported for Dropbox yet.");
  }
}, [allItems, activeCloud]);

const handleRenameItem = async (itemId: string, newName: string) => {
  const item = allItems.find(it => it.id === itemId);
  if (!item || !newName) return;

  setIsLoadingFiles(true);
  try {
    if (activeCloud === 'google') {
      const response = await window.gapi.client.drive.files.update({ fileId: itemId, resource: { name: newName }, fields: 'id, name' });
      setAllItems(prev => prev.map(it => it.id === itemId ? { ...it, name: response.result.name } : it));
    } else if (activeCloud === 'dropbox' && dropboxClient) {
      const parentPath = item.id.substring(0, item.id.lastIndexOf('/'));
      const response = await dropboxClient.filesMoveV2({ from_path: item.id, to_path: `${parentPath}/${newName}` });
      const renamedItem = response.result.metadata;
      setAllItems(prev => prev.map(it => it.id === itemId ? { ...it, id: renamedItem.path_lower, name: renamedItem.name } : it));
    }
  } catch (error) {
    console.error("Error renaming item:", error);
    alert("Failed to rename item.");
  } finally {
    setIsLoadingFiles(false);
  }
};

const handleDeleteItem = useCallback(async (itemId: string) => {
  if (!window.confirm('Are you sure you want to delete this item?')) return;
  setIsLoadingFiles(true);
  try {
    if (activeCloud === 'google') {
      await window.gapi.client.drive.files.delete({ fileId: itemId });
    } else if (activeCloud === 'dropbox' && dropboxClient) {
      await dropboxClient.filesDeleteV2({ path: itemId });
    }
    setAllItems(prev => prev.filter(it => it.id !== itemId));
    if (selectedItem?.id === itemId) setSelectedItem(null);
  } catch (error) {
    console.error("Error deleting item:", error);
  } finally {
    setIsLoadingFiles(false);
  }
}, [activeCloud, dropboxClient, selectedItem?.id]);

const handleCreateFolder = async () => {
  if (!activeCloud || !currentFolderId) return;
  const folderName = window.prompt("Enter new folder name:");
  if (!folderName) return;

  setIsLoadingFiles(true);
  try {
    let newFolder: FileItem;
    if (activeCloud === 'google') {
      const response = await window.gapi.client.drive.files.create({
        resource: { name: folderName, mimeType: 'application/vnd.google-apps.folder', parents: [currentFolderId] },
        fields: 'id, name, mimeType, modifiedTime, starred, parents, size',
      });
      const file = response.result;
      newFolder = { id: file.id, name: file.name, type: ItemType.FOLDER, parentId: file.parents[0], mimeType: file.mimeType, isStarred: file.starred, sharedWith: [], modified: new Date(file.modifiedTime).toLocaleDateString() };
    } else if (activeCloud === 'dropbox' && dropboxClient) {
      const path = (currentFolderId === 'root' ? '' : currentFolderId) + '/' + folderName;
      const response = await dropboxClient.filesCreateFolderV2({ path, autorename: true });
      const entry = response.result.metadata;
      newFolder = { id: entry.path_lower, name: entry.name, type: ItemType.FOLDER, parentId: currentFolderId, isStarred: false, sharedWith: [], modified: new Date().toLocaleDateString() };
    } else return;
    setAllItems(prev => [...prev, newFolder]);
  } catch (error) {
    console.error("Error creating folder:", error);
  } finally {
    setIsLoadingFiles(false);
  }
};

const handleUploadClick = () => {
  if (!activeCloud) alert("Please connect to a cloud service to upload files.");
  else fileInputRef.current?.click();
};

const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
  const file = event.target.files?.[0];
  if (!file || !activeCloud || !currentFolderId) return;
  setIsLoadingFiles(true);
  try {
    let newFile: FileItem;
    if (activeCloud === 'google') {
      const metadata = { name: file.name, parents: [currentFolderId] };
      const form = new FormData();
      form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
      form.append('file', file);
      const accessToken = window.gapi.client.getToken().access_token;
      const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
        method: 'POST', headers: { 'Authorization': `Bearer ${accessToken}` }, body: form,
      });
      const result = await res.json();
      if (!res.ok) throw new Error(result.error.message);
      const fileMeta = await window.gapi.client.drive.files.get({ fileId: result.id, fields: 'id, name, mimeType, modifiedTime, starred, parents, size' });
      const f = fileMeta.result;
      newFile = { id: f.id, name: f.name, type: ItemType.FILE, parentId: f.parents[0], mimeType: f.mimeType, isStarred: !!f.starred, sharedWith: [], modified: new Date(f.modifiedTime).toLocaleDateString(), size: f.size };
    } else if (activeCloud === 'dropbox' && dropboxClient) {
      const path = (currentFolderId === 'root' ? '' : currentFolderId) + '/' + file.name;
      const response = await dropboxClient.filesUpload({ path, contents: file });
      const entry = response.result;
      newFile = { id: entry.path_lower, name: entry.name, type: ItemType.FILE, parentId: currentFolderId, isStarred: false, sharedWith: [], modified: new Date(entry.client_modified).toLocaleDateString(), size: entry.size };
    } else return;
    setAllItems(prev => [...prev, newFile]);
  } catch (error) {
    console.error("Error uploading file:", error);
  } finally {
    setIsLoadingFiles(false);
    if (fileInputRef.current) fileInputRef.current.value = "";
  }
};

const handlePreviewClick = async (item: FileItem) => {
  if (item.url) {
    setFullScreenPreviewItem(item);
    return;
  }

  if (!activeCloud) {
    setFullScreenPreviewItem(item);
    return;
  }

  setIsLoadingFiles(true);
  try {
    let url = '';
    if (activeCloud === 'google') {
      const response = await window.gapi.client.drive.files.get({
        fileId: item.id,
        fields: 'webViewLink, webContentLink'
      });
      // Google Drive webViewLink is usually a viewer. We can try to use it or embed it.
      // For embedding, replacing /view with /preview often works for Google Drive files.
      url = response.result.webViewLink.replace('/view', '/preview');
    } else if (activeCloud === 'dropbox' && dropboxClient) {
      // Use cloudId (Dropbox ID) if available, otherwise fallback to path (item.id)
      const path = item.cloudId || item.id;
      const response = await dropboxClient.filesGetTemporaryLink({ path });
      url = response.result.link;
    }

    if (url) {
      setFullScreenPreviewItem({ ...item, url });
    } else {
      setFullScreenPreviewItem(item); // Fallback to showing "No URL" message
    }
  } catch (error) {
    console.error("Error fetching preview URL:", error);
    alert("Failed to load document preview.");
  } finally {
    setIsLoadingFiles(false);
  }
};

const handleFetchFileContent = async (item: FileItem): Promise<string | null> => {
  if (!activeCloud) return null;
  try {
    if (activeCloud === 'google') {
      const response = await window.gapi.client.drive.files.get({
        fileId: item.id,
        alt: 'media'
      });
      return response.body; // This might be raw text or need handling for binary
    } else if (activeCloud === 'dropbox' && dropboxClient) {
      // Use cloudId (Dropbox ID) if available, otherwise fallback to path (item.id)
      const path = item.cloudId || item.id;
      const response = await dropboxClient.filesDownload({ path });
      const blob = response.result.fileBlob;
      return await blob.text(); // Assuming text for now, might need base64 for PDF
    }
  } catch (error) {
    console.error("Error fetching file content:", error);
  }
  return null;
};

const renderContent = () => {
  const commonProps = {
    onItemClick: handleItemClick,
    onToggleStar: handleToggleStar,
    onDeleteItem: handleDeleteItem,
    onShareItem: (item: FileItem) => setSharingItem(item),
    onRenameItem: handleRenameItem,
  };
  if (isLoadingFiles || isConnecting) {
    return <div className="flex items-center justify-center h-full"><LoaderCircle className="w-12 h-12 text-primary animate-spin" /></div>;
  }
  switch (activePage) {
    case 'home': return <HomeView
      user={currentUser}
      isDriveConnected={isDriveConnected}
      isDropboxConnected={isDropboxConnected}
      onConnectGoogleDrive={handleConnectGoogleDrive}
      onDisconnectGoogleDrive={handleDisconnectGoogleDrive}
      onConnectDropbox={handleConnectDropbox}
      onDisconnectDropbox={handleDisconnectDropbox}
      onNavigateToCloud={() => handleSetPage('cloud')}
      storageInfo={{
        provider: activeCloud,
        used: 114,
        total: activeCloud === 'google' ? 15 : 0
      }}
      recentFiles={recentFiles}
      onItemClick={commonProps.onItemClick}
      onToggleStar={commonProps.onToggleStar}
      onShareItem={commonProps.onShareItem}
    />;
    case 'all-files': return <AllFilesView viewMode={viewMode} items={displayedItems} path={path} onNavigate={handleNavigate} isCloudConnected={!!activeCloud} onConnectDrive={() => handleSetPage('cloud')} {...commonProps} />;
    case 'starred': return <StarredView items={starredItems} viewMode={viewMode} {...commonProps} />;
    case 'atas': return <AtaView items={ataItems} viewMode={viewMode} {...commonProps} />;
    case 'cloud': return <CloudConnectionsView isDriveConnected={isDriveConnected} isDropboxConnected={isDropboxConnected} onConnectGoogleDrive={handleConnectGoogleDrive} onDisconnectGoogleDrive={handleDisconnectGoogleDrive} onConnectDropbox={handleConnectDropbox} onDisconnectDropbox={handleDisconnectDropbox} />;
    default: return null;
  }
};

if (isLoadingSession) {
  return <div className="flex items-center justify-center h-screen bg-[#F7F9FC]"><LoaderCircle className="w-12 h-12 text-primary animate-spin" /></div>;
}

if (!session) {
  return authView === 'login' ? (
    <LoginView onNavigateToSignup={() => setAuthView('signup')} />
  ) : (
    <SignupView onNavigateToLogin={() => setAuthView('login')} />
  );
}

if (!currentUser) return <div className="flex items-center justify-center h-screen bg-[#F7F9FC]"><LoaderCircle className="w-12 h-12 text-primary animate-spin" /></div>;

return (
  <div className="flex h-screen bg-[#F7F9FC] font-sans overflow-hidden">
    <ConnectCloudModal isOpen={isConnectModalOpen} onConnect={handleModalConnect} onSkip={handleModalSkip} isConnecting={isConnecting} />

    {/* Sidebar */}
    <Sidebar
      activePage={activePage}
      onNavigate={handleSetPage}
      storageUsed={114} // Mocked for now
      storageTotal={15} // Mocked for now
      isOpen={isSidebarOpen}
      onClose={() => setSidebarOpen(false)}
      onLogout={async () => {
        await supabase.auth.signOut();
        setDriveConnected(false);
        setDropboxConnected(false);
        setActiveCloud(null);
      }}
    />

    {/* Main Content */}
    <div className="flex-1 flex flex-col min-w-0 overflow-hidden relative">
      {/* Header */}
      <Header
        user={currentUser}
        onSearch={handleSearch}
        onToggleSidebar={() => setSidebarOpen(!isSidebarOpen)}
        title={activePage === 'home' ? 'Meu Linkarbox' : activePage === 'starred' ? 'Favoritos' : activePage === 'atas' ? 'Atas de Reunião' : activePage === 'cloud' ? 'Conexões' : currentFolderId === 'root' ? 'Todos os Arquivos' : 'Navegando...'}
      />

      {/* Content Area */}
      <main className="flex-1 overflow-y-auto p-4 md:p-6 relative">
        {renderContent()}
      </main>

      {/* Full Screen Preview */}
      {fullScreenPreviewItem && (
        <PdfViewerModal
          file={fullScreenPreviewItem}
          isOpen={!!fullScreenPreviewItem}
          onClose={() => setFullScreenPreviewItem(null)}
          cloudProvider={activeCloud || 'dropbox'} // Default to dropbox if null, but logic should prevent this
          accessToken={activeCloud === 'google' ? gapi.client.getToken()?.access_token : undefined} // Pass token for Google
        />
      )}
    </div>

    {/* Modals */}
    <ShareModal
      isOpen={!!sharingItem}
      onClose={() => setSharingItem(null)}
      item={sharingItem}
    />

    {/* Hidden File Input for Upload */}
    <input
      type="file"
      ref={fileInputRef}
      className="hidden"
      onChange={handleFileChange}
    />
  </div>
);
}
